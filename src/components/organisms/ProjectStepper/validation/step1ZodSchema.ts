import { z } from 'zod'
import { FIELD_VALIDATION_RULES } from './step1FieldValidation'

// Helper function to create Zod schema from field validation rules
const createZodSchema = () => {
  const schemaFields: Record<string, z.ZodTypeAny> = {}

  Object.entries(FIELD_VALIDATION_RULES).forEach(([fieldName, rule]) => {
    let fieldSchema: z.ZodTypeAny

    // Auto-generated fields - handle mfId as required, unitIban as optional
    const autoGeneratedFields = ['mfId', 'unitIban']
    if (autoGeneratedFields.includes(fieldName)) {
      if (fieldName === 'mfId') {
        // mfId is required for submission
        fieldSchema = z.string().min(1, 'Management Firm  ID is mandatory')
      } else {
        // unitIban is optional
        fieldSchema = z.string().optional().nullable()
      }

      // Add max length validation if specified
      if ('maxLength' in rule && rule.maxLength && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) =>
            !val || (typeof val === 'string' && val.length <= rule.maxLength!),
          {
            message: `${rule.message} (max ${rule.maxLength} characters)`,
          }
        )
      }
    } else {
      // Regular fields
      if (rule.required && 'message' in rule) {
        fieldSchema = z.string().min(1, rule.message)
      } else {
        fieldSchema = z.string().optional().nullable()
      }

      // Add max length validation
      if ('maxLength' in rule && rule.maxLength && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) =>
            !val || (typeof val === 'string' && val.length <= rule.maxLength!),
          {
            message: `${rule.message} (max ${rule.maxLength} characters)`,
          }
        )
      }

      // Add pattern validation
      if ('pattern' in rule && rule.pattern && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) => !val || (typeof val === 'string' && rule.pattern!.test(val)),
          {
            message: rule.message,
          }
        )
      }

      // Add options validation
      if ('options' in rule && rule.options && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) =>
            !val || (typeof val === 'string' && rule.options!.includes(val)),
          {
            message: rule.message,
          }
        )
      }
    }

    schemaFields[fieldName] = fieldSchema
  })

  return schemaFields
}

// Create the base schema
const baseSchemaFields = createZodSchema()

// Extended schema with additional fields from Step1 component
export const step1ZodSchema = z.object({
  // Project Details
  mfId: baseSchemaFields.mfId,
  mfId: baseSchemaFields.mfId,
  mfName: baseSchemaFields.mfName,
  mfLocation: z.string().min(1, 'Management Firm  Location is mandatory'),
  mfReraNumber: baseSchemaFields.mfReraNumber,
  mfAccoutStatusDate: z.any().optional(), // Dayjs object
  mfAccStatusDate: z.any().optional(), // Dayjs object
  mfRegistrationDate: z.any().refine((val) => val != null, {
    message: 'Management Firm  Registration Date is mandatory',
  }), // Dayjs object
  mfStartDate: z.any().refine((val) => val != null, {
    message: 'Management Firm  Start Date is mandatory',
  }), // Dayjs object
  mfCompletionDate: z.any().refine((val) => val != null, {
    message: 'Management Firm  Completion Date is mandatory',
  }), // Dayjs object
  mfRetentionPercent: z
    .string()
    .min(1, 'Retention % is mandatory')
    .refine((val) => /^\d+(\.\d{1,2})?%?$/.test(val), {
      message: 'Invalid percentage format',
    }),
  mfAdditionalRetentionPercent: z
    .string()
    .optional()
    .nullable()
    .refine((val) => !val || /^\d+(\.\d{1,2})?%?$/.test(val), {
      message: 'Invalid percentage format',
    }),
  mfTotalRetentionPercent: z.string().optional().nullable(),
  mfRetentionEffectiveDate: z.any().refine((val) => val != null, {
    message: 'Retention Effective Start Date is mandatory',
  }), // Dayjs object
  mfPercentComplete: z.string().optional().nullable(),
  mfConstructionCost: z.number().optional().nullable(),
  mfNoOfUnits: z.number().optional().nullable(),
  mfRemarks: z.string().optional().nullable(),
  mfSpecialApproval: z.string().optional().nullable(),
  mfManagedBy: baseSchemaFields.mfManagedBy,
  mfBackupUser: z.string().optional().nullable(),
  mfManagementExpenses: z
    .string()
    .min(1, 'Management Firm  Management Expenses is mandatory')
    .refine((val) => /^\d+(\.\d{1,2})?$/.test(val), {
      message: 'Invalid amount format',
    }),
  mfMarketingExpenses: z
    .string()
    .min(1, 'Marketing Expenses is mandatory')
    .refine((val) => /^\d+(\.\d{1,2})?$/.test(val), {
      message: 'Invalid amount format',
    }),
  mfTeamLeadName: z.string().optional().nullable(),
  mfRelationshipManagerName: z.string().optional().nullable(),
  mfAssestRelshipManagerName: z.string().optional().nullable(),
  mfRealEstateBrokerExp: z.number().optional().nullable(),
  mfAdvertisementExp: z.number().optional().nullable(),
  mfLandOwnerName: z.string().optional().nullable(),

  // DTO objects
  assetRegisterDTO: z.object({
    id: z.number().min(1, 'Asset Registry ID is mandatory'),
    arCifrera: z.string().min(1, 'Asset Registry CIF is required'),
    arName: z.string().optional(),
    arMasterName: z.string().optional(),
  }),
  mfStatusDTO: z.object({
    id: z.number().min(1, 'Management Firm  Status is mandatory'),
  }),
  mfTypeDTO: z.object({
    id: z.number().min(1, 'Management Firm  Type is mandatory'),
  }),
  mfAccountStatusDTO: z.object({
    id: z.number().min(1, 'Management Firm  Account Status is mandatory'),
  }),
  mfConstructionCostCurrencyDTO: z.object({
    id: z.number().min(1, 'Currency is mandatory'),
  }),

  // Additional fields
  status: z.string().optional(),
  mfBlockPaymentTypeDTO: z.any().optional(),

  // Unit/Property fields from validation rules
  unitReferenceNumber: baseSchemaFields.unitReferenceNumber,
  unitNumber: baseSchemaFields.unitNumber,
  unitStatus: baseSchemaFields.unitStatus,
  towerBuildingName: baseSchemaFields.towerBuildingName,
  unitPlotSize: baseSchemaFields.unitPlotSize,
  propertyId: baseSchemaFields.propertyId,
  unitIban: baseSchemaFields.unitIban,
  unitRegistrationFee: baseSchemaFields.unitRegistrationFee,
  nameOfAgent: baseSchemaFields.nameOfAgent,
  agentNationalId: baseSchemaFields.agentNationalId,
  grossSalePrice: baseSchemaFields.grossSalePrice,
  salePrice: baseSchemaFields.salePrice,
  vatApplicable: z.boolean().optional(),
  deedNumber: baseSchemaFields.deedNumber,
  agreementNumber: baseSchemaFields.agreementNumber,
  agreementDate: z.any().optional(), // Dayjs object
  salePurchaseAgreement: z.boolean().optional(),
  projectPaymentPlan: z.boolean().optional(),
  paymentPlanSelection: baseSchemaFields.paymentPlanSelection,
  worldCheck: baseSchemaFields.worldCheck,
  amountPaidToDeveloperWithinEscrow:
    baseSchemaFields.amountPaidToDeveloperWithinEscrow,
  amountPaidToDeveloperOutOfEscrow:
    baseSchemaFields.amountPaidToDeveloperOutOfEscrow,
  totalAmountPaid: baseSchemaFields.totalAmountPaid,
  reservationBookingForm: z.boolean().optional(),
  unitAreaSize: baseSchemaFields.unitAreaSize,
  forfeitAmount: baseSchemaFields.forfeitAmount,
  refundAmount: baseSchemaFields.refundAmount,
  transferredAmount: baseSchemaFields.transferredAmount,
  additionalRemarks: baseSchemaFields.additionalRemarks,
})

// Refined schema with conditional and calculation validations
export const refinedStep1ZodSchema = step1ZodSchema
  .refine(
    (data) => {
      // Conditional validation: Tower/Building Name is mandatory when Property ID is Unit (3)
      if (
        data.propertyId === '3' &&
        (!data.towerBuildingName ||
          (typeof data.towerBuildingName === 'string' &&
            data.towerBuildingName.trim() === ''))
      ) {
        return false
      }
      return true
    },
    {
      message: 'Tower/Building Name is mandatory when Property ID is Unit (3)',
      path: ['towerBuildingName'],
    }
  )
  .refine(
    (data) => {
      // Calculation validation: Total Amount Paid must equal Gross Sale Price + Amount Paid to Asset Registry Out of Escrow
      if (
        data.totalAmountPaid &&
        data.grossSalePrice &&
        data.amountPaidToDeveloperOutOfEscrow
      ) {
        const grossSalePrice =
          parseFloat(
            typeof data.grossSalePrice === 'string' ? data.grossSalePrice : '0'
          ) || 0
        const amountOutOfEscrow =
          parseFloat(
            typeof data.amountPaidToDeveloperOutOfEscrow === 'string'
              ? data.amountPaidToDeveloperOutOfEscrow
              : '0'
          ) || 0
        const totalAmount =
          parseFloat(
            typeof data.totalAmountPaid === 'string'
              ? data.totalAmountPaid
              : '0'
          ) || 0
        const expectedTotal = grossSalePrice + amountOutOfEscrow

        return Math.abs(totalAmount - expectedTotal) < 0.01
      }
      return true
    },
    {
      message:
        'Total Amount Paid must equal Gross Sale Price + Amount Paid to Asset Registry Out of Escrow',
      path: ['totalAmountPaid'],
    }
  )

// Export the final schema
export const step1ValidationSchema = refinedStep1ZodSchema

// Type inference from schema
export type Step1FormData = z.infer<typeof step1ValidationSchema>

// Validation function that can be used with React Hook Form
export const validateStep1Form = (data: any) => {
  try {
    step1ValidationSchema.parse(data)
    return { isValid: true, errors: {} }
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errors: Record<string, string> = {}
      error.issues.forEach((err: any) => {
        const path = err.path.join('.')
        errors[path] = err.message
      })
      return { isValid: false, errors }
    }
    return { isValid: false, errors: { general: 'Validation failed' } }
  }
}

// Individual field validation function
// Returns: true for valid, error message string for invalid (React Hook Form compatible)
export const validateStep1Field = (
  fieldName: string,
  value: any,
  formData?: any
): string | true => {
  try {
    // Handle nested field paths like 'assetRegisterDTO.id'
    if (fieldName.includes('.')) {
      const [parentField, childField] = fieldName.split('.')

      // For nested fields, validate just that nested field
      if (parentField && childField) {
        const parentSchema = (step1ValidationSchema.shape as any)[parentField]
        if (parentSchema && typeof parentSchema.shape === 'object') {
          const childSchema = parentSchema.shape[childField]
          if (childSchema) {
            const result = childSchema.safeParse(value)
            if (!result.success) {
              const error = result.error.issues[0]
              return error?.message || 'Invalid value'
            }
            return true
          }
        }
      }
      return true
    }

    // Handle simple field paths - validate just the single field
    const fieldSchema = (step1ValidationSchema.shape as any)[fieldName]

    if (!fieldSchema) {
      // Field not in schema, skip validation
      return true
    }

    // Validate the field value using safeParse
    const parseResult = fieldSchema.safeParse(value)

    if (!parseResult.success) {
      const error = parseResult.error.issues[0]
      const errorMessage = error?.message || 'Invalid value'
      return errorMessage
    }

    // Additional validation: check conditional validation if formData is provided
    if (formData && fieldName === 'towerBuildingName') {
      const conditionalResult = refinedStep1ZodSchema.safeParse({
        ...formData,
        [fieldName]: value,
      })
      if (!conditionalResult.success) {
        const fieldError = conditionalResult.error.issues.find(
          (issue) => issue.path.join('.') === fieldName
        )
        if (fieldError) {
          return fieldError.message
        }
      }
    }

    // Additional validation: check calculation validation if formData is provided
    if (formData && fieldName === 'totalAmountPaid') {
      const calculationResult = refinedStep1ZodSchema.safeParse({
        ...formData,
        [fieldName]: value,
      })
      if (!calculationResult.success) {
        const fieldError = calculationResult.error.issues.find(
          (issue) => issue.path.join('.') === fieldName
        )
        if (fieldError) {
          return fieldError.message
        }
      }
    }

    return true
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Return the first error message for this field
      const firstError = error.issues[0]
      const errorMessage = firstError?.message || 'Invalid value'

      return errorMessage
    }

    return 'Validation failed'
  }
}
