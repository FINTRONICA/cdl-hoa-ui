import { z } from 'zod'
import { FIELD_VALIDATION_RULES } from './step1FieldValidation'

// Helper function to create Zod schema from field validation rules
const createZodSchema = () => {
  const schemaFields: Record<string, z.ZodTypeAny> = {}

  Object.entries(FIELD_VALIDATION_RULES).forEach(([fieldName, rule]) => {
    let fieldSchema: z.ZodTypeAny

    // Auto-generated fields - handle reaId as required, unitIban as optional
    const autoGeneratedFields = ['reaId', 'unitIban']
    if (autoGeneratedFields.includes(fieldName)) {
      if (fieldName === 'reaId') {
        // reaId is required for submission
        fieldSchema = z.string().min(1, 'Project ID is mandatory')
      } else {
        // unitIban is optional
        fieldSchema = z.string().optional()
      }
      
      // Add max length validation if specified
      if ('maxLength' in rule && rule.maxLength && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) => !val || (typeof val === 'string' && val.length <= rule.maxLength!),
          {
            message: `${rule.message} (max ${rule.maxLength} characters)`
          }
        )
      }
    } else {
      // Regular fields
      if (rule.required && 'message' in rule) {
        fieldSchema = z.string().min(1, rule.message)
      } else {
        fieldSchema = z.string().optional()
      }

      // Add max length validation
      if ('maxLength' in rule && rule.maxLength && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) => !val || (typeof val === 'string' && val.length <= rule.maxLength!),
          {
            message: `${rule.message} (max ${rule.maxLength} characters)`
          }
        )
      }

      // Add pattern validation
      if ('pattern' in rule && rule.pattern && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) => !val || (typeof val === 'string' && rule.pattern!.test(val)),
          {
            message: rule.message
          }
        )
      }

      // Add options validation
      if ('options' in rule && rule.options && 'message' in rule) {
        fieldSchema = fieldSchema.refine(
          (val) => !val || (typeof val === 'string' && rule.options!.includes(val)),
          {
            message: rule.message
          }
        )
      }
    }

    schemaFields[fieldName] = fieldSchema
  })

  return schemaFields
}

// Create the base schema
const baseSchemaFields = createZodSchema()

// Extended schema with additional fields from Step1 component
export const step1ZodSchema = z.object({
  // Project Details
  reaId: baseSchemaFields.reaId,
  reaCif: baseSchemaFields.reaCif,
  reaName: baseSchemaFields.reaName,
  reaLocation: z.string().min(1, 'Project Location is mandatory'),
  reaReraNumber: baseSchemaFields.reaReraNumber,
  reaAccoutStatusDate: z.any().optional(), // Dayjs object
  reaAccStatusDate: z.any().optional(), // Dayjs object
  reaRegistrationDate: z.any().refine((val) => val != null, { message: 'Project Registration Date is mandatory' }), // Dayjs object
  reaStartDate: z.any().refine((val) => val != null, { message: 'Project Start Date is mandatory' }), // Dayjs object
  reaCompletionDate: z.any().refine((val) => val != null, { message: 'Project Completion Date is mandatory' }), // Dayjs object
  reaRetentionPercent: z.string()
    .min(1, 'Retention % is mandatory')
    .refine(
      (val) => /^\d+(\.\d{1,2})?%?$/.test(val),
      { message: 'Invalid percentage format' }
    ),
  reaAdditionalRetentionPercent: z.string()
    .optional()
    .refine(
      (val) => !val || /^\d+(\.\d{1,2})?%?$/.test(val),
      { message: 'Invalid percentage format' }
    ),
  reaTotalRetentionPercent: z.string().optional(),
  reaRetentionEffectiveDate: z.any().refine((val) => val != null, { message: 'Retention Effective Start Date is mandatory' }), // Dayjs object
  reaPercentComplete: z.string().optional(),
  reaConstructionCost: z.number().optional(),
  reaNoOfUnits: z.number().optional(),
  reaRemarks: z.string().optional(),
  reaSpecialApproval: z.string().optional(),
  reaManagedBy: baseSchemaFields.reaManagedBy,
  reaBackupUser: z.string().optional(),
  reaManagementExpenses: z.string()
    .min(1, 'Project Management Expenses is mandatory')
    .refine(
      (val) => /^\d+(\.\d{1,2})?$/.test(val),
      { message: 'Invalid amount format' }
    ),
  reaMarketingExpenses: z.string()
    .min(1, 'Marketing Expenses is mandatory')
    .refine(
      (val) => /^\d+(\.\d{1,2})?$/.test(val),
      { message: 'Invalid amount format' }
    ),
  reaTeamLeadName: z.string().optional(),
  reaRelationshipManagerName: z.string().optional(),
  reaAssestRelshipManagerName: z.string().optional(),
  reaRealEstateBrokerExp: z.number().optional(),
  reaAdvertisementExp: z.number().optional(),
  reaLandOwnerName: z.string().optional(),

  // DTO objects
  buildPartnerDTO: z.object({
    id: z.number().min(1, 'Developer ID is mandatory'),
    bpCifrera: z.string().optional(),
    bpName: z.string().optional(),
    bpMasterName: z.string().optional()
  }),
  reaStatusDTO: z.object({
    id: z.number().min(1, 'Project Status is mandatory')
  }),
  reaTypeDTO: z.object({
    id: z.number().min(1, 'Project Type is mandatory')
  }),
  reaAccountStatusDTO: z.object({
    id: z.number().min(1, 'Project Account Status is mandatory')
  }),
  reaConstructionCostCurrencyDTO: z.object({
    id: z.number().min(1, 'Currency is mandatory')
  }),

  // Additional fields
  status: z.string().optional(),
  reaBlockPaymentTypeDTO: z.any().optional(),

  // Unit/Property fields from validation rules
  unitReferenceNumber: baseSchemaFields.unitReferenceNumber,
  unitNumber: baseSchemaFields.unitNumber,
  unitStatus: baseSchemaFields.unitStatus,
  towerBuildingName: baseSchemaFields.towerBuildingName,
  unitPlotSize: baseSchemaFields.unitPlotSize,
  propertyId: baseSchemaFields.propertyId,
  unitIban: baseSchemaFields.unitIban,
  unitRegistrationFee: baseSchemaFields.unitRegistrationFee,
  nameOfAgent: baseSchemaFields.nameOfAgent,
  agentNationalId: baseSchemaFields.agentNationalId,
  grossSalePrice: baseSchemaFields.grossSalePrice,
  salePrice: baseSchemaFields.salePrice,
  vatApplicable: z.boolean().optional(),
  deedNumber: baseSchemaFields.deedNumber,
  agreementNumber: baseSchemaFields.agreementNumber,
  agreementDate: z.any().optional(), // Dayjs object
  salePurchaseAgreement: z.boolean().optional(),
  projectPaymentPlan: z.boolean().optional(),
  paymentPlanSelection: baseSchemaFields.paymentPlanSelection,
  worldCheck: baseSchemaFields.worldCheck,
  amountPaidToDeveloperWithinEscrow: baseSchemaFields.amountPaidToDeveloperWithinEscrow,
  amountPaidToDeveloperOutOfEscrow: baseSchemaFields.amountPaidToDeveloperOutOfEscrow,
  totalAmountPaid: baseSchemaFields.totalAmountPaid,
  reservationBookingForm: z.boolean().optional(),
  unitAreaSize: baseSchemaFields.unitAreaSize,
  forfeitAmount: baseSchemaFields.forfeitAmount,
  refundAmount: baseSchemaFields.refundAmount,
  transferredAmount: baseSchemaFields.transferredAmount,
  additionalRemarks: baseSchemaFields.additionalRemarks,
})

// Refined schema with conditional and calculation validations
export const refinedStep1ZodSchema = step1ZodSchema
  .refine(
    (data) => {
      // Conditional validation: Tower/Building Name is mandatory when Property ID is Unit (3)
      if (data.propertyId === '3' && (!data.towerBuildingName || (typeof data.towerBuildingName === 'string' && data.towerBuildingName.trim() === ''))) {
        return false
      }
      return true
    },
    {
      message: 'Tower/Building Name is mandatory when Property ID is Unit (3)',
      path: ['towerBuildingName']
    }
  )
  .refine(
    (data) => {
      // Calculation validation: Total Amount Paid must equal Gross Sale Price + Amount Paid to Developer Out of Escrow
      if (data.totalAmountPaid && data.grossSalePrice && data.amountPaidToDeveloperOutOfEscrow) {
        const grossSalePrice = parseFloat(typeof data.grossSalePrice === 'string' ? data.grossSalePrice : '0') || 0
        const amountOutOfEscrow = parseFloat(typeof data.amountPaidToDeveloperOutOfEscrow === 'string' ? data.amountPaidToDeveloperOutOfEscrow : '0') || 0
        const totalAmount = parseFloat(typeof data.totalAmountPaid === 'string' ? data.totalAmountPaid : '0') || 0
        const expectedTotal = grossSalePrice + amountOutOfEscrow
        
        return Math.abs(totalAmount - expectedTotal) < 0.01
      }
      return true
    },
    {
      message: 'Total Amount Paid must equal Gross Sale Price + Amount Paid to Developer Out of Escrow',
      path: ['totalAmountPaid']
    }
  )

// Export the final schema
export const step1ValidationSchema = refinedStep1ZodSchema

// Type inference from schema
export type Step1FormData = z.infer<typeof step1ValidationSchema>

// Validation function that can be used with React Hook Form
export const validateStep1Form = (data: any) => {
  try {
    step1ValidationSchema.parse(data)
    return { isValid: true, errors: {} }
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errors: Record<string, string> = {}
      error.issues.forEach((err: any) => {
        const path = err.path.join('.')
        errors[path] = err.message
      })
      return { isValid: false, errors }
    }
    return { isValid: false, errors: { general: 'Validation failed' } }
  }
}

// Individual field validation function
// Returns: true for valid, error message string for invalid (React Hook Form compatible)
export const validateStep1Field = (fieldName: string, value: any, formData?: any): string | true => {
  try {
    // Handle nested field paths like 'buildPartnerDTO.id'
    if (fieldName.includes('.')) {
      const [parentField, childField] = fieldName.split('.')
      
      // For nested fields, validate just that nested field
      if (parentField && childField) {
        const parentSchema = (step1ValidationSchema.shape as any)[parentField]
        if (parentSchema && typeof parentSchema.shape === 'object') {
          const childSchema = parentSchema.shape[childField]
          if (childSchema) {
            const result = childSchema.safeParse(value)
            if (!result.success) {
              const error = result.error.issues[0]
              return error?.message || 'Invalid value'
            }
            return true
          }
        }
      }
      return true
    }
    
    // Handle simple field paths - validate just the single field
    const fieldSchema = (step1ValidationSchema.shape as any)[fieldName]
    
    if (!fieldSchema) {
      // Field not in schema, skip validation
      return true
    }
    
    // Validate the field value using safeParse
    const parseResult = fieldSchema.safeParse(value)
    
    if (!parseResult.success) {
      const error = parseResult.error.issues[0]
      const errorMessage = error?.message || 'Invalid value'
      return errorMessage
    }
    
    // Additional validation: check conditional validation if formData is provided
    if (formData && fieldName === 'towerBuildingName') {
      const conditionalResult = refinedStep1ZodSchema.safeParse({ ...formData, [fieldName]: value })
      if (!conditionalResult.success) {
        const fieldError = conditionalResult.error.issues.find(issue => 
          issue.path.join('.') === fieldName
        )
        if (fieldError) {
          
          return fieldError.message
        }
      }
    }
    
    // Additional validation: check calculation validation if formData is provided
    if (formData && fieldName === 'totalAmountPaid') {
      const calculationResult = refinedStep1ZodSchema.safeParse({ ...formData, [fieldName]: value })
      if (!calculationResult.success) {
        const fieldError = calculationResult.error.issues.find(issue => 
          issue.path.join('.') === fieldName
        )
        if (fieldError) {
          
          return fieldError.message
        }
      }
    }
    
    return true
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Return the first error message for this field
      const firstError = error.issues[0]
      const errorMessage = firstError?.message || 'Invalid value'
      
      return errorMessage
    }
    
    return 'Validation failed'
  }
}
